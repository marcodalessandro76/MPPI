{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import os\n",
    "import matplotlib.pyplot as plt\n",
    "from importlib import reload\n",
    "\n",
    "basepath = os.getcwd()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tests of new features"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Use this notebook to test some modifications on the classes without the need to reinstall the package "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.insert(0,'/home/marco/Applications/MPPI/mppi/InputFiles/')\n",
    "sys.path.insert(0,'/home/marco/Applications/MPPI/mppi/Calculators/')\n",
    "sys.path.insert(0,'/home/marco/Applications/MPPI/mppi/Datasets/')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import PwIn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "reload(PwIn)\n",
    "input = PwIn.PwIn()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "&control\n",
      "           verbosity = 'high'\n",
      "         calculation = 'nscf'\n",
      "          pseudo_dir = '../pseudos'\n",
      "/&end\n",
      "&system\n",
      "                nbnd = 12\n",
      "               ibrav = 0\n",
      "                ntyp = 1\n",
      "                 nat = 2\n",
      "             ecutwfc = 80\n",
      "/&end\n",
      "&electrons\n",
      "            conv_thr = 1e-08\n",
      "/&end\n",
      "ATOMIC_SPECIES\n",
      "   C   12.011   C_pbe-20082014.UPF\n",
      "ATOMIC_POSITIONS { angstrom }\n",
      "  C   0.0000000000   0.0000000000   0.0000000000\n",
      "  C   0.0000000000   1.4200000000   0.0000000000\n",
      "K_POINTS { automatic }\n",
      "  6  6  1  0  0  0\n",
      "CELL_PARAMETERS angstrom\n",
      "  2.4595121467   0.0000000000   0.0000000000 \n",
      "  1.2297560734   2.1300000000   0.0000000000 \n",
      "  0.0000000000   0.0000000000  10.0000000000 \n",
      "\n"
     ]
    }
   ],
   "source": [
    "k = 6\n",
    "ecut = 80\n",
    "a0 = 1.42\n",
    "planeSep  = 10.0\n",
    "A = [0.,0.,0.]\n",
    "B = [0.,a0,0.]\n",
    "a1 = [a0*np.sqrt(3),0.,0.]\n",
    "a2 = [a0*np.sqrt(3)/2,a0*3./2,0.]\n",
    "a3 = [0.,0.,planeSep]\n",
    "\n",
    "input.set_calculation('nscf')\n",
    "input.system['nbnd'] = 12\n",
    "input.set_pseudo_dir('../pseudos')\n",
    "input.system['ibrav'] = 0\n",
    "input.cell_parameters =[a1,a2,a3]\n",
    "input.set_atoms_type(1)\n",
    "input.set_atoms_number(2)\n",
    "input.set_atoms_position(pos_type='angstrom',pos_list=[['C',A],['C',B]])\n",
    "input.atypes = {'C': [12.011,'C_pbe-20082014.UPF']}\n",
    "input.set_convergence_thr(1e-8)\n",
    "#prefix = 'k'+str(k)+'_ecut'+str(ecut)\n",
    "#input.set_prefix(prefix)\n",
    "input.set_kpoints(ktype='automatic',kpoints=[k,k,1])\n",
    "input.set_energy_cutoff(ecut)\n",
    "\n",
    "print(input)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## pre_processing for dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In some cases it can be useful to perform some preliminary operations before running a computation. E.g. copy of the scf save folder in the appropriate location before starting with a nscf computation or preparing the SAVE folder before a Yambo computation.\n",
    "\n",
    "For this reason we can introduce a pre_processing function "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "import QeCalculator as QeC\n",
    "import Datasets as D"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<module 'Datasets' from '/home/marco/Applications/MPPI/mppi/Datasets/Datasets.py'>"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reload(D)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initialize a qe calculator with command OMP_NUM_THREADS=1 mpirun -np 4 pw.x\n"
     ]
    }
   ],
   "source": [
    "code = QeC.QeCalculator(omp=1,mpi_run='mpirun -np 4',executable='pw.x',verbose=True,skip=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "study = D.Dataset(label='prova',run_dir='nscf',pre_processing='nscf',source_dir='gs_run_dir')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'nscf'"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "study.pre_processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'pre_processing': 'nscf', 'source_dir': 'gs_run_dir'}"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "study.kwargs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "kpoints = [3,6]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "for k in kpoints:\n",
    "    idd = {'k' : k, 'ecut' : 100} \n",
    "    input.set_prefix(D.name_from_id(idd))\n",
    "    input.set_kpoints(ktype='automatic',kpoints=[k,k,1])\n",
    "    input.set_energy_cutoff(100)\n",
    "    study.append_run(id=idd,calculator=code,input=input)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "&control\n",
      "           verbosity = 'high'\n",
      "         calculation = 'nscf'\n",
      "          pseudo_dir = '../pseudos'\n",
      "              prefix = 'ecut:100,k:6'\n",
      "/&end\n",
      "&system\n",
      "                nbnd = 12\n",
      "               ibrav = 0\n",
      "                ntyp = 1\n",
      "                 nat = 2\n",
      "             ecutwfc = 100\n",
      "/&end\n",
      "&electrons\n",
      "            conv_thr = 1e-08\n",
      "/&end\n",
      "ATOMIC_SPECIES\n",
      "   C   12.011   C_pbe-20082014.UPF\n",
      "ATOMIC_POSITIONS { angstrom }\n",
      "  C   0.0000000000   0.0000000000   0.0000000000\n",
      "  C   0.0000000000   1.4200000000   0.0000000000\n",
      "K_POINTS { automatic }\n",
      "  6  6  1  0  0  0\n",
      "CELL_PARAMETERS angstrom\n",
      "  2.4595121467   0.0000000000   0.0000000000 \n",
      "  1.2297560734   2.1300000000   0.0000000000 \n",
      "  0.0000000000   0.0000000000  10.0000000000 \n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(study.runs[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 324,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "nsct save folder already exsists. Save folder NOT COPIED\n",
      "nsct save folder already exsists. Save folder NOT COPIED\n",
      "execute : cd nscf ; OMP_NUM_THREADS=1 mpirun -np 4 pw.x -inp ecut:100,k:3.in > ecut:100,k:3.log\n",
      "execute : cd nscf ; OMP_NUM_THREADS=1 mpirun -np 4 pw.x -inp ecut:100,k:6.in > ecut:100,k:6.log\n"
     ]
    }
   ],
   "source": [
    "study.run()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tests of YamboIn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import YamboIn as YI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/home/marco/Applications/MPPI/tutorials'"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "os.chdir(basepath)\n",
    "os.getcwd()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "to perform test the SAVE folder is needed by Yambo, so we use the yambo_test folder where a SAVE directory has been copied"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<module 'YamboIn' from '/home/marco/Applications/MPPI/mppi/InputFiles/YamboIn.py'>"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reload(YI)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The approach used to deal with yambo input files is to call yamboIn with the specific run level. Yambo build a base input file that calls 'yambo.in'. The parameters of the input can be set and the updated file can be written on disk with its specific name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "fold = 'yambo_test'\n",
    "fname = 'yambo_test.in'\n",
    "\n",
    "y = YI.YamboIn('yambo -x -V rl',folder=fold)\n",
    "y['EXXRLvcs'] = [1000.0*3,'mHa']\n",
    "krange = y['QPkrange'][0][:2]\n",
    "kbandrange = krange + [1,10]\n",
    "y['QPkrange'] = [kbandrange,'']\n",
    "y.write(fold+'/'+fname)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "HF_and_locXC\n",
      "FFTGvecs = 941.000000 RL\n",
      "SE_Threads = 0.000000e+00 \n",
      "EXXRLvcs = 3000.000000 mHa\n",
      "% QPkrange\n",
      " 1 | 4 | 1 | 10 |   \n",
      "%\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tests of YamboCalculator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "ename": "ImportError",
     "evalue": "attempted relative import with no known parent package",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mImportError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-8-042ff20ca0b6>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0;32mimport\u001b[0m \u001b[0mYamboCalculator\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mYbC\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m~/Applications/MPPI/mppi/Calculators/YamboCalculator.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mos\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 7\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0;34m.\u001b[0m\u001b[0mYamboParser\u001b[0m \u001b[0;32mimport\u001b[0m  \u001b[0mYamboOut\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      8\u001b[0m \u001b[0;31m#import YamboParser as yp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      9\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mImportError\u001b[0m: attempted relative import with no known parent package"
     ]
    }
   ],
   "source": [
    "import YamboCalculator as YbC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<module 'YamboCalculator' from '/home/marco/Applications/MPPI/mppi/Calculators/YamboCalculator.py'>"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reload(YbC)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initialize a Yambo calculator with command OMP_NUM_THREADS=1 mpirun -np 4 yambo\n"
     ]
    }
   ],
   "source": [
    "code = YbC.YamboCalculator(omp=1,mpi_run='mpirun -np 4',executable='yambo',verbose=True,skip=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "skip the computation for : yambo_test/ybc_test/o-ybc_test.hf\n",
      "output in :  yambo_test/ybc_test/o-ybc_test.hf\n"
     ]
    }
   ],
   "source": [
    "results = code.run(input=y,name='ybc_test',run_dir='yambo_test',post_processing=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['K-point', 'Band', 'Eo', 'Ehf', 'DFT', 'HF'])"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Il codice del parsing puo essere implementato in un file separato che YamboCalculator importa, esattamente come faccio per il pw_out di QE. Questo modulo che posso chiamare YamboParser puo stare dentro la folder Calculators"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Devo elaborare ulteriormente il parser in modo che mi ridia un dizionario. Per farlo DÃ¬devo prendere le chiavi dalla riga dell'output che contiene K-points e poi devo costruire il dizionario attribuendo correttamente chiavi e valori"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 192,
   "metadata": {},
   "outputs": [],
   "source": [
    "fname = 'yambo_test/ybc_test/o-ybc_test.hf'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 193,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['K-point', 'Band', 'Eo', 'Ehf', 'DFT', 'HF']"
      ]
     },
     "execution_count": 193,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "line_keys = []\n",
    "with open(fname) as f:\n",
    "    for l in f:\n",
    "        if 'K-point' in l:\n",
    "            line_keys.append(l)\n",
    "            break\n",
    "keys = line_keys[0].split()[1:]\n",
    "keys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 205,
   "metadata": {},
   "outputs": [],
   "source": [
    "parse = {}\n",
    "for ind,key in enumerate(keys):\n",
    "    parse[key] = []\n",
    "    for line in results:\n",
    "        parse[key].append(line[ind])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 208,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import YamboParser as yp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 209,
   "metadata": {},
   "outputs": [],
   "source": [
    "fname = 'yambo_test/ybc_test/o-ybc_test.hf'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 212,
   "metadata": {},
   "outputs": [],
   "source": [
    "reload(yp)\n",
    "results = yp.YamboOut(fname)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 213,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'K-point': [1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  1.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  2.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  3.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0,\n",
       "  4.0],\n",
       " 'Band': [1.0,\n",
       "  2.0,\n",
       "  3.0,\n",
       "  4.0,\n",
       "  5.0,\n",
       "  6.0,\n",
       "  7.0,\n",
       "  8.0,\n",
       "  9.0,\n",
       "  10.0,\n",
       "  1.0,\n",
       "  2.0,\n",
       "  3.0,\n",
       "  4.0,\n",
       "  5.0,\n",
       "  6.0,\n",
       "  7.0,\n",
       "  8.0,\n",
       "  9.0,\n",
       "  10.0,\n",
       "  1.0,\n",
       "  2.0,\n",
       "  3.0,\n",
       "  4.0,\n",
       "  5.0,\n",
       "  6.0,\n",
       "  7.0,\n",
       "  8.0,\n",
       "  9.0,\n",
       "  10.0,\n",
       "  1.0,\n",
       "  2.0,\n",
       "  3.0,\n",
       "  4.0,\n",
       "  5.0,\n",
       "  6.0,\n",
       "  7.0,\n",
       "  8.0,\n",
       "  9.0,\n",
       "  10.0],\n",
       " 'Eo': [-11.88783,\n",
       "  -2.027e-05,\n",
       "  0.0,\n",
       "  0.0,\n",
       "  2.565313,\n",
       "  2.565343,\n",
       "  2.56534,\n",
       "  3.17618,\n",
       "  7.74153,\n",
       "  7.74153,\n",
       "  -9.57842,\n",
       "  -6.91786,\n",
       "  -1.18965,\n",
       "  -1.18963,\n",
       "  1.486111,\n",
       "  3.355662,\n",
       "  3.355685,\n",
       "  7.7181,\n",
       "  10.54694,\n",
       "  10.54695,\n",
       "  -7.77748,\n",
       "  -7.77744,\n",
       "  -2.82411,\n",
       "  -2.8241,\n",
       "  0.740817,\n",
       "  0.740843,\n",
       "  9.98059,\n",
       "  9.98063,\n",
       "  10.96007,\n",
       "  10.96007,\n",
       "  -9.5784,\n",
       "  -6.91791,\n",
       "  -1.18963,\n",
       "  -1.18963,\n",
       "  1.48615,\n",
       "  3.355678,\n",
       "  3.35568,\n",
       "  7.71811,\n",
       "  10.54695,\n",
       "  10.54695],\n",
       " 'Ehf': [-17.74335,\n",
       "  -2.61,\n",
       "  -1.96785,\n",
       "  -1.54064,\n",
       "  7.488659,\n",
       "  7.687541,\n",
       "  7.7565,\n",
       "  8.81729,\n",
       "  13.78133,\n",
       "  13.68595,\n",
       "  -14.66745,\n",
       "  -10.14034,\n",
       "  -3.78242,\n",
       "  -2.94007,\n",
       "  6.290171,\n",
       "  8.265098,\n",
       "  8.563054,\n",
       "  12.72993,\n",
       "  16.75301,\n",
       "  17.39897,\n",
       "  -11.76619,\n",
       "  -12.06433,\n",
       "  -5.16013,\n",
       "  -5.25937,\n",
       "  5.506235,\n",
       "  5.040718,\n",
       "  16.71961,\n",
       "  16.7184,\n",
       "  17.2115,\n",
       "  17.16894,\n",
       "  -14.36776,\n",
       "  -10.77228,\n",
       "  -3.05488,\n",
       "  -3.24603,\n",
       "  6.035261,\n",
       "  8.30409,\n",
       "  9.20062,\n",
       "  12.76191,\n",
       "  16.63943,\n",
       "  17.06854],\n",
       " 'DFT': [-10.42439,\n",
       "  -10.83,\n",
       "  -11.47596,\n",
       "  -11.90318,\n",
       "  -9.793085,\n",
       "  -9.991936,\n",
       "  -10.06089,\n",
       "  -10.62355,\n",
       "  -10.12245,\n",
       "  -10.02706,\n",
       "  -10.71535,\n",
       "  -10.39173,\n",
       "  -10.67606,\n",
       "  -11.5184,\n",
       "  -9.786038,\n",
       "  -9.289845,\n",
       "  -9.587768,\n",
       "  -7.0014,\n",
       "  -9.96471,\n",
       "  -10.61067,\n",
       "  -10.98786,\n",
       "  -10.68967,\n",
       "  -10.66169,\n",
       "  -10.56244,\n",
       "  -8.919391,\n",
       "  -8.45384,\n",
       "  -10.43907,\n",
       "  -10.43782,\n",
       "  -10.53624,\n",
       "  -10.49367,\n",
       "  -11.01501,\n",
       "  -9.75986,\n",
       "  -11.40359,\n",
       "  -11.21243,\n",
       "  -9.53105,\n",
       "  -9.328822,\n",
       "  -10.22536,\n",
       "  -7.03337,\n",
       "  -9.85111,\n",
       "  -10.28022],\n",
       " 'HF': [-16.27991,\n",
       "  -13.44,\n",
       "  -13.44382,\n",
       "  -13.44382,\n",
       "  -4.869738,\n",
       "  -4.869738,\n",
       "  -4.86974,\n",
       "  -4.98244,\n",
       "  -4.08265,\n",
       "  -4.08265,\n",
       "  -15.80438,\n",
       "  -13.61421,\n",
       "  -13.26883,\n",
       "  -13.26884,\n",
       "  -4.981978,\n",
       "  -4.38041,\n",
       "  -4.380399,\n",
       "  -1.98957,\n",
       "  -3.75864,\n",
       "  -3.75864,\n",
       "  -14.97658,\n",
       "  -14.97656,\n",
       "  -12.99771,\n",
       "  -12.99772,\n",
       "  -4.153973,\n",
       "  -4.153965,\n",
       "  -3.70006,\n",
       "  -3.70006,\n",
       "  -4.28481,\n",
       "  -4.2848,\n",
       "  -15.80437,\n",
       "  -13.61423,\n",
       "  -13.26884,\n",
       "  -13.26883,\n",
       "  -4.981939,\n",
       "  -4.380411,\n",
       "  -4.38041,\n",
       "  -1.98958,\n",
       "  -3.75863,\n",
       "  -3.75863]}"
      ]
     },
     "execution_count": 213,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
