"""
This module contains functions and a class to manage with the Density of States (Dos).
A Dos can be built starting from various inputs like the output of QuantumESPRESSO or a
Yambo computations or from a generic one-dimensional array. Different Dos can be managed together.
"""

def lorentzian(eta,x0,x):
    """
    Get the lorentzian function.
    """
    import numpy as np
    s2 = eta**2
    c = eta/np.pi
    x1 = (x-x0)**2
    return c/(x1+s2)

def gaussian(eta,x0,x):
    """
    Get the gaussian function.
    """
    import numpy as np
    c = 1.0/(eta*np.sqrt(2.0*np.pi))
    x1 = ((x-x0)/eta)**2
    return c*np.exp(-0.5*x1)

def build_histogram(values,weights=None,minVal=None,maxVal=None,
                    step=0.01,eta=0.05,broad_kind=lorentzian):
    """
    This function build the histogram associated to a generic one-dimensional array.
    If the weights are not specified a uniform array of weights, normalized to one, is assumed.

    Args:
        values:class:`numpy.array`) : one-dimensional array with the values of the energy
        weights (:py:class:`numpy.array`) : one-dimensional array with the weight of each value.
            If None a uniform array normalized to one is used
        minVal (float) : values lower than this parameter are not included in the histogram
        maxVal (float) : values higher than this parameter are not included in the histogram
        step (float) : size of the bin (in the same units used for the values array)
        eta (float) : magnitude of the broading parameter (in the same units used for the values array)
        broad_kind (string) : type of broading function used (lorentzian, gaussian)

    Return:
        (tuple) : (x axis of the histogram,histogram values)


    """
    import numpy as np

    # set the weights and the range
    if weights is None:
        weights = np.ones(len(values))/len(values)
    if minVal is None:
        minVal = values.min() - 10.*eta
    if maxVal is None:
        maxVal = values.max() + 10.*eta

    # print('values',values)
    # print('weights',weights)
    # print('minVal',minVal)
    # print('maxVal',maxVal)
    # print('broad_kind',broad_kind)
    #cut the values and weights out from the range [minVal,maxVal]
    weights = weights[minVal < values]
    values = values[minVal < values]
    weights = weights[values < maxVal]
    values = values[values < maxVal]

    x = np.arange(minVal,maxVal,step)
    histo = np.zeros([len(x)])
    for v,w in zip(values,weights):
        histo += w*broad_kind(eta,v,x)

    return (x, histo)

def dos_fromPwParser(results,set_gap=None,set_direct_gap=None):
    """
    Parse the QuantumESPRESSO xml file and build the one-dimensional arrays
    energies and weights needed for building the dos using the build_histogram
    function.

    Args:
        results (:py:class:`string`) : the data-file-schema.xml that contains the result of the
                        QuantumESPRESSO computation
        set_gap (float) : set the value of the gap (in eV) of the system
        set_direct_gap (float) : set the value of the direct gap (in eV) of the system. If set_gap
                        is provided this parameter is ignored

    Return:
        (tuple) : (array with the energies,array with the associated weights)

    """
    from mppi import Parsers as P
    import numpy as np

    data = P.PwParser(results,verbose=False)
    energies = data.get_evals(set_gap,set_direct_gap)
    weights = np.ones(energies.shape)*data.weights
    return (energies.flatten(),weights.flatten())

class Dos():
    """
    Definition of the density of state class.
    """

    def __init__(self, energies = None, weights = None, label = None, **kwargs):
        self.dos = []
        self.labels = []
        if energies is not None:
            self.append(energies,weights=weights,label=label,**kwargs)

    def append(self,energies, weights = None, label = None,
            minVal = None, maxVal = None, step = 0.01, eta = 0.05, broad_kind = lorentzian):
        """
        This method add the tuple (x,histo) generated by the function build_histogram
        to the members of the class.
        """
        #print('label',label)
        self.dos.append(build_histogram(energies,weights,minVal,maxVal,
                   step,eta,broad_kind))
        lbl = label if label is not None else str(len(self.labels)+1)
        self.labels.append(lbl)

    @classmethod
    def from_Pw(cls,results,set_gap=None,set_direct_gap=None,label=None,**kwargs):
        """
        Initialize the Dos class from the result of a QuantumESPRESSO computation.
        The class makes usage of the PwParser of this package.

        Args:
            results (:py:class:`string`) : the data-file-schema.xml that contains the result of the
                            QuantumESPRESSO computation
            set_gap (:py:class:`float`) : set the value of the gap (in eV) of the system
            set_direct_gap (:py:class:`float`) : set the value of the direct gap (in eV) of the system.
                            If set_gap is provided this parameter is ignored

        """
        energies, weights = dos_fromPwParser(results,set_gap,set_direct_gap)
        return cls(energies,weights=weights,label=label,**kwargs)

    def append_fromPw(self,results,set_gap=None,set_direct_gap=None,label=None,**kwargs):
        """
        Add one element to the Dos class starting from the results of a QuantumESPRESSO
        computation.

        """
        energies, weights = dos_fromPwParser(results,set_gap,set_direct_gap)
        self.append(energies,weights=weights,label=label,**kwargs)

    def plot(self,plt):
        """
        Plot the elemenyÃ¬ts of the Dos class
        """
        for ind,dos in enumerate(self.dos):
            plt.plot(dos[0],dos[1],label=self.labels[ind])













####################################################################


AU_eV = 27.21138386

class DiracSuperposition():
    """
    Defines as superposition of Dirac deltas which can be used to
    plot the density of states
    """

    def __init__(self, dos, wgts=[1.0]):
        """
        Parameters:
           dos: array containing the density of states per eack k-point.
                Should be of shape 2
           wgts: contains the weights of each of the k-points
        """
        import numpy as np
        self.dos = dos
        if isinstance(wgts, float):
            self.norm = [wgts]
        else:
            self.norm = wgts
        # set range for this distribution
        e_min = 1.e100
        e_max = -1.e100
        ddos = np.ravel(dos)
        if len(ddos) > 0:
            e_min = min(e_min, np.min(ddos) - 0.05 *
                        (np.max(ddos) - np.min(ddos)))
            e_max = max(e_max, np.max(ddos) + 0.05 *
                        (np.max(ddos) - np.min(ddos)))
        self.xlim = (e_min, e_max)

    def curve(self, xs, sigma, wgts=None):
        import numpy as np
        dos_g = 0.0
        idos = 0
        for norm, dos in zip(self.norm, self.dos):
            if wgts is not None:
                norms = wgts[idos]*norm
                idos += 1
            else:
                norms = np.ones(len(dos))*norm
            kptcurve = self.peaks(xs, dos, norms, sigma)
            dos_g += kptcurve
        return xs, dos_g

    def peak(self, omega, e, sigma):
        """
        Define if a peak is a Gaussian or a Lorenzian (temporarily only the
        gaussian is defined)
        """
        import numpy as np
        nfac = np.sqrt(2.0*np.pi)
        val = np.exp(- (omega - e)**2 / (2.0 * sigma**2))/(nfac*sigma)
        return val

    def peaks(self, xs, dos, norms, sigma):
        """
        Return the array of the whole set of peaks
        """
        curve = 0.0
        for e, nrm in zip(dos, norms):
            curve += self.peak(xs, e, sigma)*nrm
        return curve


# def _bandarray_to_data(jspin, bandarrays):
#     lbl = 'up' if jspin == 0 else 'dw'
#     kptlists = [[], []]
#     for orbs in bandarrays:
#         for ispin, norbs in enumerate(orbs.info):
#             if norbs == 0 or ispin != jspin:
#                 continue
#             # energy values
#             kptlists[0].append(orbs[ispin, :norbs])
#             # normalization
#             kptlists[1].append(orbs.kwgt*(1.0-2*ispin))
#             # print 'kpt',kptlists
#     return kptlists, lbl


class Dos_Big():
    """
    Definition of the density of state class
    """

    def __init__(self, bandarrays=None, energies=None, evals=None, units='eV',
                 label='1', sigma=0.2/AU_eV, npts=2500, fermi_level=None,
                 norm=1.0, sdos=None):
        """
        Extract a quantity which is associated to the DoS, that can be plotted
        """
        import numpy as np
        self.ens = []
        self.labels = []
        # self.norms=[]
        self.npts = npts
        # if bandarrays is not None:
        #     self.append_from_bandarray(bandarrays, label)
        if evals is not None:
            self.append_from_dict(evals, label)
        if energies is not None:
            self.append(np.array([energies]), label=label, units=units,
                        norm=(np.array([norm])
                        if isinstance(norm, float) else norm))
        self.sigma = self.conversion_factor(units)*sigma
        self.fermi_level(fermi_level, units=units)
        if sdos is not None:
            self._embed_sdos(sdos)

    def _embed_sdos(self, sdos):
        self.sdos = []
        for i, xdos in enumerate(sdos):
            self.sdos.append({'coord': xdos['coord']})
            jdos = 0
            for subspin in xdos['dos']:
                if len(subspin[0]) == 0:
                    continue
                d = {'doslist': subspin}
                try:
                    self.ens[jdos]['sdos'].append(d)
                except KeyError:
                    self.ens[jdos]['sdos'] = [d]
                jdos += 1

    # def append_from_bandarray(self, bandarrays, label):
    #     """
    #     Add a new band array to the previous DoS. Important for kpoints DOS
    #     """
    #     import numpy as np
    #     for jspin in range(2):
    #         kptlists, lbl = _bandarray_to_data(jspin, bandarrays)
    #         self.append(np.array(kptlists[0]), label=label+lbl, units='AU',
    #                     norm=np.array(kptlists[1]))

    # def append_from_dict(self, evals, label):
    #     import numpy as np
    #     "Get the energies from the different flavours given by the dict"
    #     evs = [[], []]
    #     ef = None
    #     for ev in evals:
    #         occ = self.get_ev(ev, ['e_occ', 'e_occupied'])
    #         if occ:
    #             ef = max(occ)
    #         vrt = self.get_ev(ev, ['e_vrt', 'e_virt'])
    #         eigen = False
    #         if occ:
    #             eigen = occ
    #         if vrt:
    #             eigen = vrt
    #         if not eigen:
    #             eigen = self.get_ev(ev)
    #         if not occ and not vrt and eigen:
    #             ef = max(eigen)
    #         if not eigen:
    #             continue
    #         for i, e in enumerate(eigen):
    #             if e:
    #                 evs[i].append(e)
    #     for i, energs in enumerate(evs):
    #         if len(energs) == 0:
    #             continue
    #         self.append(np.array(energs), label=label,
    #                     units='AU', norm=1.0-2.0*i)
    #     if ef:
    #         self.fermi_level(ef, units='AU')

    def get_ev(self, ev, keys=None):
        "Get the correct list of the energies for this eigenvalue"
        res = False
        if keys is None:
            ener = ev.get('e')
            spin = ev.get('s')
            if ener and spin == 1:
                res = [ener]
            elif ener and spin == -1:
                res = [None, ener]
        else:
            for k in keys:
                if k in ev:
                    res = ev[k]
                    if not isinstance(res, list):
                        res = [res]
                    break
        return res

    def append(self, energies, label=None, units='eV', norm=1.0):
        if not isinstance(norm, float) and len(norm) == 0:
            return
        dos = self.conversion_factor(units)*energies
        self.ens.append({'dos': DiracSuperposition(dos, wgts=norm)})
        lbl = label if label is not None else str(len(self.labels)+1)
        self.labels.append(lbl)
        # self.norms.append(norm)
        self.range = self._set_range()

    def conversion_factor(self, units):
        if units == 'AU':
            fac = AU_eV
        elif units == 'eV':
            fac = 1.0
        else:
            raise ValueError('Unrecognized units ('+units+')')
        return fac

    def fermi_level(self, fermi_level, units='eV'):
        if fermi_level is not None:
            self.ef = fermi_level*self.conversion_factor(units)

    def _set_range(self, npts=None):
        import numpy as np
        if npts is None:
            npts = self.npts
        e_min = 1.e100
        e_max = -1.e100
        for dos in self.ens:
            mn, mx = dos['dos'].xlim
            e_min = min(e_min, mn)
            e_max = max(e_max, mx)
        return np.arange(e_min, e_max, (e_max-e_min)/npts)

    def curve(self, dos, norm, sigma=None):
        import numpy as np
        if sigma is None:
            sigma = self.sigma
        nrm = np.sqrt(2.0*np.pi)*sigma/norm
        dos_g = []
        for e_i in self.range:
            if len(dos.shape) == 2:
                nkpt = dos.shape[0]
                value = 0.0
                for ikpt in range(nkpt):
                    value += np.sum(np.exp(- (e_i - dos[ikpt, :])**2 /
                                           (2.0 * sigma**2))/nrm[ikpt])
            else:
                value = np.sum(
                    np.exp(- (e_i - dos[:])**2 / (2.0 * sigma**2))/nrm)
            # Append data corresponding to each energy grid
            dos_g.append(value)
        return np.array(dos_g)

    def plot(self, sigma=None, legend=True, xlmin=None, xlmax=None, ylmin=None,
             ylmax=None):
        import matplotlib.pyplot as plt
        from matplotlib.widgets import Slider  # , Button, RadioButtons
        if sigma is None:
            sigma = self.sigma
        self.fig, self.ax1 = plt.subplots()
        self.plotl = []
        for i, dos in enumerate(self.ens):
            # self.plotl.append(self.ax1.plot(self.range,self.curve(dos,norm=self.norms[i],sigma=sigma),label=self.labels[i]))
            self.plotl.append(self.ax1.plot(
                *dos['dos'].curve(self.range, sigma=sigma),
                label=self.labels[i]))
        if xlmax is not None:
            plt.xlim(xmax=xlmax)
        if xlmin is not None:
            plt.xlim(xmin=xlmin)
        if ylmax is not None:
            plt.ylim(ymax=ylmax)
        if ylmin is not None:
            plt.ylim(ymin=ylmin)
        plt.xlabel('Energy [eV]', fontsize=18)
        plt.ylabel('DoS', fontsize=18)
        if self.ef is not None:
            plt.axvline(self.ef, color='k', linestyle='--')
        if len(self.labels) > 1 and legend:
            plt.legend(loc='best')
        axcolor = 'lightgoldenrodyellow'
        plt.show()
