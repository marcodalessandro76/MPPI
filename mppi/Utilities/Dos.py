"""
This module defines the tools to build and manage the Density of States (Dos).
A Dos can be built starting from various inputs like the output of QuantumESPRESSO or a
Yambo computations or from a generic one-dimensional array. Different Dos can be managed together.
"""

def lorentzian(eta,x0,x):
    """
    Get the lorentzian function.
    """
    import numpy as np
    s2 = eta**2
    c = eta/np.pi
    x1 = (x-x0)**2
    return c/(x1+s2)

def gaussian(eta,x0,x):
    """
    Get the gaussian function.
    """
    import numpy as np
    c = 1.0/(eta*np.sqrt(2.0*np.pi))
    x1 = ((x-x0)/eta)**2
    return c*np.exp(-0.5*x1)

def build_histogram(values,weights=None,minVal=None,maxVal=None,
                    step=0.01,eta=0.05,broad_kind=lorentzian):
    """
    This function builds the histogram associated to a generic one-dimensional array.
    If the weights are not specified a uniform array of weights, normalized to one, is assumed.

    Args:
        values (:class:`numpy.array`) : one-dimensional array with the values used to build the Dos
        weights (:py:class:`numpy.array`) : one-dimensional array with the weight of each value.
            If None a uniform array normalized to one is used
        minVal (float) : values lower than this parameter are not included in the histogram
        maxVal (float) : values higher than this parameter are not included in the histogram
        step (float) : size of the bin (in the same units used for the values array)
        eta (float) : magnitude of the broading parameter (in the same units used for the values array)
        broad_kind (string) : type of broading function used (lorentzian, gaussian)

    Return:
        (tuple) : tuple containing:
            (:py:class:`numpy.array`) : x axis of the histogram

            (:py:class:`numpy.array`) :histogram values


    """
    import numpy as np
    # set the weights and the range
    if weights is None:
        weights = np.ones(len(values))/len(values)
    if minVal is None:
        minVal = values.min() - 10.*eta
    if maxVal is None:
        maxVal = values.max() + 10.*eta

    weights = weights[minVal < values]
    values = values[minVal < values]
    weights = weights[values < maxVal]
    values = values[values < maxVal]

    x = np.arange(minVal,maxVal,step)
    histo = np.zeros([len(x)])
    for v,w in zip(values,weights):
        histo += w*broad_kind(eta,v,x)

    return (x, histo)

def convert_PwData(evals,weights):
    """
    Convert the arrays with the structure of evals and weights of the PwParser class
    into the form suitable to be managed by the build_histogram function.

    Args:
        evals (:py:class:`numpy.array`) : array with the structure of the self.evals of
            PwParser
        weights (:py:class:`numpy.array`) : array with the structure of the self.weights of
            PwParser

    Return:
        (tuple) : tuple containing:
            (:py:class:`numpy.array`) : one-dimensioanal array with the energies

            (:py:class:`numpy.array`) : one-dimensional array with the associated weights

    """
    import numpy as np
    weights = np.ones(evals.shape)*weights
    return (evals.flatten(),weights.flatten())

class Dos():
    """
    Definition of the density of state class.

    Add further description....

    Attributes:
        dos :
        labels :
        
    """

    def __init__(self, energies = None, weights = None, label = None, **kwargs):
        self.dos = []
        self.labels = []
        if energies is not None:
            self.append(energies,weights=weights,label=label,**kwargs)

    def append(self,energies, weights = None, label = None,
            minVal = None, maxVal = None, step = 0.01, eta = 0.05, broad_kind = lorentzian):
        """
        This method add the tuple (x,histo) generated by the function build_histogram
        to the dos members of the class. The label of the new dos is added to the labels
        member.
        """
        self.dos.append(build_histogram(energies,weights,minVal,maxVal,
                   step,eta,broad_kind))
        lbl = label if label is not None else str(len(self.labels)+1)
        self.labels.append(lbl)

    @classmethod
    def from_Pw(cls,results,set_gap=None,set_direct_gap=None,label=None,**kwargs):
        """
        Initialize the Dos class from the xml output file of a QuantumESPRESSO computation.
        The class makes usage of the PwParser of this package.

        Args:
            results (:py:class:`string`) : the data-file-schema.xml that contains the result of the
                            QuantumESPRESSO computation
            set_gap (:py:class:`float`) : set the value of the gap (in eV) of the system
            set_direct_gap (:py:class:`float`) : set the value of the direct gap (in eV) of the system.
                            If set_gap is provided this parameter is ignored
            kwargs (kwargs) : optional parameters useful to pass further information to the append
                method (like minVal,maxVal,step,eta,broad_kind)

        """
        from mppi import Parsers as P

        data = P.PwParser(results,verbose=False)
        evals = data.get_evals(set_gap,set_direct_gap)
        energies, weights = convert_PwData(evals,data.weights)
        return cls(energies,weights=weights,label=label,**kwargs)

    def append_fromPw(self,results,set_gap=None,set_direct_gap=None,label=None,**kwargs):
        """
        Add one element to the Dos class starting from the xml output file of a QuantumESPRESSO
        computation.

        Args:
            results (:py:class:`string`) : the data-file-schema.xml that contains the result of the
                            QuantumESPRESSO computation
            set_gap (:py:class:`float`) : set the value of the gap (in eV) of the system
            set_direct_gap (:py:class:`float`) : set the value of the direct gap (in eV) of the system.
                            If set_gap is provided this parameter is ignored
            label (string) : the label of the appended dos
            kwargs (kwargs) : optional parameters useful to pass further information to the append
                method (like minVal,maxVal,step,eta,broad_kind)

        """
        from mppi import Parsers as P

        data = P.PwParser(results,verbose=False)
        evals = data.get_evals(set_gap,set_direct_gap)
        energies, weights = convert_PwData(evals,data.weights)
        self.append(energies,weights=weights,label=label,**kwargs)

    def append_fromPwData(self,evals,weights,label=None,**kwargs):
        """
        Add one element to the Dos class starting from arrays with the structure of the
        evals and weights attributes of the PwParser class. This method can be used to
        build a JDos, using the transitions as evals.

        Args:
            evals (:py:class:`numpy.array`) : array with the structure of the self.evals of
                the PwParser
            weights (:py:class:`numpy.array`) : array with the structure of the self.weights of
                the PwParser
            label (string) : the label of the appended dos
            kwargs (kwargs) : optional parameters useful to pass further information to the append
                method (like minVal,maxVal,step,eta,broad_kind)

        """
        energies, weights = convert_PwData(evals,weights)
        self.append(energies,weights=weights,label=label,**kwargs)

    def plot(self,plt):
        """
        Plot the elements of the Dos class
        """
        for ind,dos in enumerate(self.dos):
            plt.plot(dos[0],dos[1],label=self.labels[ind])

#from whypy
#     def getJDOS(self,broad=0.1,emin=0,emax=10,step=0.01,ctype="lorentzian"):
#         """
#         Calculate the joint density of states
#         """
#         transitions = self.get_transitions()
#         weights = self.weights_ibz
#
#         na = np.newaxis
#         weights_transitions = np.ones(transitions.shape,dtype=np.float32)*weights[:,na]
#         energies, self.jdos = histogram_eiv(self.transitions,weights_transitions,emin=emin,emax=emax,step=step,sigma=broad,ctype=ctype)
#
#         return energies, self.jdos
